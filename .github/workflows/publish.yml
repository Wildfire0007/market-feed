# Trading.py
# ----- Kimenet: public/<ASSET>/(spot|klines_5m|klines_1h|signal).json -----

import os, json, time, math
from datetime import datetime, timezone
import requests

BASE = "public"
ASSETS = ["SOL", "GOLD_CFD"]  # most ezt a kettőt építjük

TD_API_KEY = os.getenv("TWELVEDATA_API_KEY", "").strip()

def nowiso():
    return datetime.now(timezone.utc).isoformat()

def ensure_dir(p):
    os.makedirs(os.path.dirname(p), exist_ok=True)

def save_json(path, obj):
    ensure_dir(path)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(obj, f, ensure_ascii=False, indent=2)

# ---------- Coinbase (SOL) ----------
def coinbase_spot(symbol="SOL"):
    url = f"https://api.exchange.coinbase.com/products/{symbol}-USD/ticker"
    r = requests.get(url, timeout=12)
    r.raise_for_status()
    j = r.json()
    price = float(j["price"])
    return {
        "asset": symbol,
        "ok": True,
        "price": price,
        "raw": j,
        "symbol": f"{symbol}/USD",
        "retrieved_at_utc": nowiso()
    }

def coinbase_klines(symbol="SOL", granularity="5m"):
    gmap = {"5m": 300, "1h": 3600}
    secs = gmap[granularity]
    url = f"https://api.exchange.coinbase.com/products/{symbol}-USD/candles?granularity={secs}"
    r = requests.get(url, timeout=15)
    r.raise_for_status()
    arr = r.json()  # [time, low, high, open, close, volume], newest first
    arr = sorted(arr, key=lambda x: x[0])  # time asc
    values = []
    for t, low, high, opn, close, vol in arr:
        dt = datetime.fromtimestamp(t, tz=timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
        values.append({
            "datetime": dt,
            "open": f"{float(opn):.2f}",
            "high": f"{float(high):.2f}",
            "low":  f"{float(low):.2f}",
            "close":f"{float(close):.2f}",
        })
    return {
        "meta": {
            "symbol": f"{symbol}/USD",
            "interval": granularity,
            "exchange": "Coinbase",
            "type": "Digital Currency",
        },
        "values": values
    }

# ---------- TwelveData (GOLD_CFD) – 5m only (kvótakímélő) ----------
# Ebből aggregálunk 1h-t és spot-ot.
def td_5m(symbol="GOLD_CFD"):
    if not TD_API_KEY:
        raise RuntimeError("TWELVEDATA_API_KEY missing")
    # GOLD_CFD 5m gyertyák (kb. 3–5 nap bőven elég)
    url = (
        "https://api.twelvedata.com/time_series?"
        f"symbol={symbol}&interval=5min&outputsize=480&timezone=UTC&format=JSON&apikey={TD_API_KEY}"
    )
    r = requests.get(url, timeout=18)
    r.raise_for_status()
    j = r.json()
    if "status" in j and j.get("status") == "error":
        # TwelveData hibaüzenet formátuma
        raise RuntimeError(j.get("message") or j)
    meta = j.get("meta", {})
    vals = j.get("values", [])
    # TD: newest first → fordítsuk idő szerint növekvőre
    vals = list(reversed(vals))
    # normalizálás
    norm = []
    for row in vals:
        # dátum string már UTC
        norm.append({
            "datetime": row["datetime"],
            "open":  row["open"],
            "high":  row["high"],
            "low":   row["low"],
            "close": row["close"],
        })
    out = {
        "meta": {
            "symbol": meta.get("symbol", symbol),
            "interval": "5m",
            "exchange": meta.get("exchange", "TwelveData"),
            "type": meta.get("type", "CFD/Commodity"),
        },
        "values": norm
    }
    return out

def aggregate_1h_from_5m(k5):
    """12*5m → 1h OHLC (egyszerű bucket az óra elejéhez igazítva)."""
    vals = k5.get("values", [])
    if not vals:
        return {"meta": {"interval": "1h"}, "values": []}

    bucket = {}
    for v in vals:
        # v["datetime"] pl. "2025-10-03 15:20:00"
        dt = datetime.strptime(v["datetime"], "%Y-%m-%d %H:%M:%S")
        hour_dt = dt.replace(minute=0, second=0)
        key = hour_dt.strftime("%Y-%m-%d %H:%M:%S")
        o = float(v["open"]); h = float(v["high"]); l = float(v["low"]); c = float(v["close"])
        if key not in bucket:
            bucket[key] = {"open": o, "high": h, "low": l, "close": c, "t": dt}
        else:
            b = bucket[key]
            # az első gyertya az órában → open
            if dt < b["t"]:
                b["open"] = o
                b["t"] = dt
            b["high"] = max(b["high"], h)
            b["low"]  = min(b["low"], l)
            # mindig az utolsó gyertya close-a
            if dt >= b["t"]:
                b["close"] = c

    keys = sorted(bucket.keys())  # idő szerint nő
    outvals = []
    for k in keys:
        b = bucket[k]
        outvals.append({
            "datetime": k,
            "open":  f"{b['open']:.2f}",
            "high":  f"{b['high']:.2f}",
            "low":   f"{b['low']:.2f}",
            "close": f"{b['close']:.2f}",
        })
    return {
        "meta": {
            "symbol": "GOLD_CFD",
            "interval": "1h",
            "exchange": "TwelveData",
            "type": "CFD/Commodity"
        },
        "values": outvals
    }

def main():
    for asset in ASSETS:
        root = os.path.join(BASE, asset)
        ensure_dir(os.path.join(root, "x"))

        # ----- SOL (Coinbase) -----
        if asset == "SOL":
            # spot
            try:
                spot = coinbase_spot("SOL")
            except Exception as e:
                spot = {"asset": "SOL", "ok": False, "error": f"spot: {e}", "retrieved_at_utc": nowiso()}
            save_json(os.path.join(root, "spot.json"), spot)

            # klines
            try:
                k5 = coinbase_klines("SOL", "5m")
            except Exception as e:
                k5 = {"ok": False, "error": f"k5m: {e}", "retrieved_at_utc": nowiso()}
            save_json(os.path.join(root, "klines_5m.json"), k5)

            try:
                k1 = coinbase_klines("SOL", "1h")
            except Exception as e:
                k1 = {"ok": False, "error": f"k1h: {e}", "retrieved_at_utc": nowiso()}
            save_json(os.path.join(root, "klines_1h.json"), k1)

            # signal – placeholder (a workerben is lesz logika)
            sig = {"asset": "SOL", "ok": True, "retrieved_at_utc": nowiso(),
                   "signal": "no entry", "reasons": ["no signal"]}
            save_json(os.path.join(root, "signal.json"), sig)

        # ----- GOLD_CFD (TwelveData 5m only) -----
        if asset == "GOLD_CFD":
            try:
                k5 = td_5m("GOLD_CFD")
                save_json(os.path.join(root, "klines_5m.json"), k5)

                # spot = legutolsó záróár a 5m-ből (nincs külön TD spot hívás → kvótakímélő)
                last_close = float(k5["values"][-1]["close"])
                spot = {
                    "asset": "GOLD_CFD",
                    "ok": True,
                    "price": last_close,
                    "symbol": "GOLD_CFD",
                    "source": "derived_from_klines_5m",
                    "retrieved_at_utc": nowiso(),
                }
                save_json(os.path.join(root, "spot.json"), spot)

                # 1h aggregálás lokálisan
                k1 = aggregate_1h_from_5m(k5)
                save_json(os.path.join(root, "klines_1h.json"), k1)

                sig = {"asset": "GOLD_CFD", "ok": True, "retrieved_at_utc": nowiso(),
                       "signal": "no entry", "reasons": ["no signal"]}
                save_json(os.path.join(root, "signal.json"), sig)

            except Exception as e:
                # ha TD hiba, írjunk hibatesteket, hogy a worker is lássa
                err = {"asset": "GOLD_CFD", "ok": False, "error": str(e), "retrieved_at_utc": nowiso()}
                save_json(os.path.join(root, "spot.json"), err)
                save_json(os.path.join(root, "klines_5m.json"), err)
                save_json(os.path.join(root, "klines_1h.json"), err)
                save_json(os.path.join(root, "signal.json"), {
                    "asset": "GOLD_CFD", "ok": False,
                    "retrieved_at_utc": nowiso(), "signal": "no entry", "reasons": ["upstream error"]
                })

if __name__ == "__main__":
    main()
