name: TD Full Pipeline (5m)

"on":
  workflow_dispatch:
    inputs:
      force_public_sync:
        description: "Kézi futtatáskor is frissítsd a public tartalmat"
        required: false
        default: "true"
  schedule:
    # GitHub Actions only guarantees cron triggers at a minimum 2-minute cadence,
    - cron: "*/2 * * * *" # 2 percenként (UTC)
    - cron: "0 5 * * *" # Napi egyszer 05:00-kor (UTC)

permissions:
  contents: write

concurrency:
  group: manual-positions-${{ github.ref }}
  cancel-in-progress: true

jobs:
  trading_and_analysis:
    name: 1) Trading.py → Analysis (egy runneren)
    runs-on: ubuntu-24.04
    timeout-minutes: 40
    env:
      TZ: UTC
      OUT_DIR: public
      TD_PAUSE: "0.3"
      TWELVEDATA_API_KEY: ${{ secrets.TWELVEDATA_API_KEY }}
      SESSION_OVERRIDE_24_7: "1"
      PIPELINE_MAX_LAG_SECONDS: "800"
      DISABLE_ML_PROBABILITY: "1"
      ML_PROBABILITY_MANUAL_OVERRIDE: "1"
      RESET_PUBLIC_ON_TRADING_START: "1"
      PUBLIC_BASE_URL: ${{ secrets.PUBLIC_BASE_URL }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 1

      - name: Sync default branch
        run: |
          git fetch origin main
          git reset --hard origin/main

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: requirements.lock

      - name: Restore Python virtualenv cache
        id: cache-venv
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ hashFiles('requirements.lock') }}
          restore-keys: |
            venv-${{ runner.os }}-

      - name: Create virtualenv (cache miss)
        if: steps.cache-venv.outputs.cache-hit != 'true'
        run: |
          python -m venv .venv
          .venv/bin/python -m pip install --upgrade pip
          .venv/bin/pip install -r requirements.lock

      - name: Activate virtualenv for subsequent steps
        run: |
          echo "VIRTUAL_ENV=$PWD/.venv" >> $GITHUB_ENV
          echo "PATH=$PWD/.venv/bin:$PATH" >> $GITHUB_ENV

      - name: Show sklearn/joblib versions
        run: |
          .venv/bin/python - <<'PY'
          import sklearn, joblib
          print("scikit-learn:", sklearn.__version__)
          print("joblib:", joblib.__version__)
          PY

      # Trading always runs first. Public is synced immediately afterwards
      # so that analysis consumes the fresh trading artefacts instead of
      # anything stale from a previous workflow run.
      - name: Run Trading.py (pull all OHLC  spot)
        run: .venv/bin/python Trading.py

      - name: Sync pipeline artifacts into public (before analysis)
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.force_public_sync != 'false'
        env:
          PUBLIC_SYNC_RUN_ID: ${{ github.run_id }}
          PUBLIC_SYNC_COMMIT: ${{ github.sha }}
        run: |
          set -euo pipefail
          .venv/bin/python scripts/update_public.py --target "${OUT_DIR:-public}" \
            --sources data reports \
            --run-id "$PUBLIC_SYNC_RUN_ID" \
            --commit "$PUBLIC_SYNC_COMMIT"

      - name: Verify public sync metadata (guards analysis sequencing)
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.force_public_sync != 'false'
        env:
          EXPECTED_RUN_ID: ${{ github.run_id }}
        run: |
          set -euo pipefail
          .venv/bin/python - <<'PY'
          from pathlib import Path
          import json
          import os
          import sys

          meta_path = Path('public/.sync-metadata.json')
          if not meta_path.exists():
            raise SystemExit("Missing public/.sync-metadata.json after sync")

          metadata = json.loads(meta_path.read_text())

          expected_run_id = os.environ.get("EXPECTED_RUN_ID")
          if not expected_run_id:
            raise SystemExit("EXPECTED_RUN_ID environment variable missing")

          if metadata.get('run_id') != expected_run_id:
            raise SystemExit(f"Unexpected run_id in metadata: {metadata.get('run_id')}")

          checksum = metadata.get('checksum')
          if not checksum:
            raise SystemExit("Empty checksum recorded for public sync")

          last_sync = Path('public/.last_sync')
          if not last_sync.exists():
            raise SystemExit("Missing public/.last_sync stamp after sync")

          print("Verified public sync metadata", metadata)
          PY

      - name: Ensure manual position state is available for analysis
        env:
          PUBLIC_BASE_URL: ${{ env.PUBLIC_BASE_URL }}
        run: |
          set -euo pipefail
          mkdir -p public
          if curl -fsSL -H "Cache-Control: no-cache" "${PUBLIC_BASE_URL}/_manual_positions.json?ts=${GITHUB_RUN_ID}" -o public/_manual_positions.json; then
            echo "manual positions restored from public"
          else
            echo '{}' > public/_manual_positions.json
            echo "manual positions fallback created"
          fi
          curl -fsSL -H "Cache-Control: no-cache" "${PUBLIC_BASE_URL}/_manual_positions_audit.jsonl?ts=${GITHUB_RUN_ID}" -o public/_manual_positions_audit.jsonl || true

      - name: Upload pipeline artifact bundle
        uses: actions/upload-artifact@v4
        with:
          name: pipeline-artifacts
          path: |
            data
            reports

      - name: Verify model exists & loadable
        run: .venv/bin/python scripts/check_ml_readiness.py BTCUSD

      - name: Run analysis (ML disabled)
        run: |
          .venv/bin/python analysis.py

      - name: Generate latency monitoring snapshot
        run: |
          .venv/bin/python scripts/check_latency_sources.py --output public/monitoring/data_latency.json --pretty

      - name: Commit and push refreshed public outputs
        if: github.ref == 'refs/heads/main'
        run: |
          set -euo pipefail
          git status
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git fetch origin main
          git pull --rebase --autostash origin main
          git add public
          if git diff --cached --quiet; then
            echo "No changes in public/ to commit."
            exit 0
          fi
          git commit -m "Auto-update analysis outputs (public/) [skip ci]"
          git push origin main

      - name: Upload analysis outputs
        uses: actions/upload-artifact@v4
        with:
          name: analysis-public
          path: public
  deploy_public:
    name: 2) Deploy refreshed public
    needs:
      - notify
    runs-on: ubuntu-24.04
    timeout-minutes: 20
    permissions:
      contents: read
      pages: write
      id-token: write
    environment:
      name: github-pages
    steps:
      - name: Deploy public folder to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
  notify:
    name: 3) Discord értesítő
    needs:
      - trading_and_analysis
    runs-on: ubuntu-24.04
    timeout-minutes: 15
    env:
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
      DISCORD_COOLDOWN_MIN: ${{ secrets.DISCORD_COOLDOWN_MIN }}
      DISCORD_COOLDOWN_MOMENTUM_MIN: ${{ secrets.DISCORD_COOLDOWN_MOMENTUM_MIN }}
      PUBLIC_BASE_URL: ${{ secrets.PUBLIC_BASE_URL }}
    steps:
      - name: Checkout latest signals
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 1

      - name: Sync with latest main
        run: |
          git fetch origin main
          git reset --hard origin/main

      - name: Prepare public directory
        run: |
          rm -rf public
          mkdir -p public

      - name: Download analysis outputs
        uses: actions/download-artifact@v4
        with:
          name: analysis-public
          path: public

      - name: Bootstrap manual positions from published state
        env:
          PUBLIC_BASE_URL: ${{ env.PUBLIC_BASE_URL }}
        run: |
          set -euo pipefail
          mkdir -p public
          if curl -fsSL -H "Cache-Control: no-cache" "${PUBLIC_BASE_URL}/_manual_positions.json?ts=${GITHUB_RUN_ID}" -o public/_manual_positions.json; then
              echo "STATE_LOADED=1" >> $GITHUB_ENV
          else
              echo '{}' > public/_manual_positions.json
              echo "STATE_LOADED=0" >> $GITHUB_ENV
          fi
          curl -fsSL -H "Cache-Control: no-cache" "${PUBLIC_BASE_URL}/_manual_positions_audit.jsonl?ts=${GITHUB_RUN_ID}" -o public/_manual_positions_audit.jsonl || true

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: requirements.lock

      - name: Restore Python virtualenv cache
        id: cache-venv
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ hashFiles('requirements.lock') }}
          restore-keys: |
            venv-${{ runner.os }}-

      - name: Create virtualenv (cache miss)
        if: steps.cache-venv.outputs.cache-hit != 'true'
        run: |
          python -m venv .venv
          .venv/bin/python -m pip install --upgrade pip
          .venv/bin/pip install -r requirements.lock

      - name: Activate virtualenv for subsequent steps
        run: |
          echo "VIRTUAL_ENV=$PWD/.venv" >> $GITHUB_ENV
          echo "PATH=$PWD/.venv/bin:$PATH" >> $GITHUB_ENV

      - name: Run Discord notifier
        env:
          STATE_LOADED: ${{ env.STATE_LOADED }}
          PUBLIC_BASE_URL: ${{ env.PUBLIC_BASE_URL }}
          MANUAL_POS_AUDIT_TO_FILE: "1"
          MANUAL_POS_AUDIT_FILE: public/_manual_positions_audit.jsonl
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            .venv/bin/python scripts/notify_discord.py --manual
          else
            .venv/bin/python scripts/notify_discord.py
          fi

      - name: Show manual positions size
        if: always()
        run: |
          ls -la public/_manual_positions.json || true
          wc -c public/_manual_positions.json || true

      - name: Verify manual position state and audit integrity
        if: always()
        run: |
          set -euo pipefail
          python - <<'PY'
          import hashlib
          import json
          import os
          from pathlib import Path

          positions_path = Path("public/_manual_positions.json")
          audit_path = Path("public/_manual_positions_audit.jsonl")

          if not positions_path.exists():
              raise SystemExit("manual positions file missing")

          digest = hashlib.sha256(positions_path.read_bytes()).hexdigest()
          size = positions_path.stat().st_size
          print(f"manual_positions sha256={digest} bytes={size}")

          audit_lines = []
          if audit_path.exists():
              audit_lines = audit_path.read_text().splitlines()
              print("---- audit tail (last 30 lines) ----")
              for line in audit_lines[-30:]:
                  print(line)
          else:
              print("audit file missing — will treat as empty")

          dispatch_success = False
          had_dispatch = False
          current_run = os.getenv("GITHUB_RUN_ID")
          for raw in audit_lines:
              try:
                  evt = json.loads(raw)
              except Exception:
                  continue
              if evt.get("event") == "ENTRY_DISPATCH_RESULT":
                  if current_run and str(evt.get("gh_run_id") or "") not in {str(current_run), str(evt.get("run_id"))}:
                      continue
                  had_dispatch = True
                  if evt.get("success") is True:
                      dispatch_success = True

          if dispatch_success:
              try:
                  positions = json.loads(positions_path.read_text())
              except Exception:
                  positions = None

              has_entries = isinstance(positions, dict) and any(
                  isinstance(v, dict) and v for v in positions.values()
              )

              if not has_entries:
                  raise SystemExit(
                      "ENTRY dispatch succeeded but manual_positions.json is empty"
                  )

          if not had_dispatch:
              print("No ENTRY_DISPATCH_RESULT events recorded in audit log")
          PY

      - name: Mirror manual positions into config directory
        if: always()
        run: |
          set -euo pipefail
          mkdir -p config
          cp public/_manual_positions.json config/manual_positions.json

      - name: Publish manual position artifacts
        uses: actions/upload-pages-artifact@v3
        with:
          path: public

