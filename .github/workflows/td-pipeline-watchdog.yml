name: TD Pipeline Watchdog

on:
  schedule:
    # GitHub Actions schedule minimum: 5 perc.
    # Watchdog fallback dispatch-eli a TD pipeline-t, ha kimarad egy ütem.
    - cron: "*/5 * * * *"
    # Második, eltolva futó ütem: kisebb esélye van annak, hogy egyszerre maradnak ki.
    - cron: "2-59/5 * * * *"  
  workflow_dispatch:

permissions:
  actions: write
  contents: read

jobs:
  ensure_td_pipeline_fresh:
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    steps:
      - name: Check TD pipeline freshness and dispatch if stale
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const workflow_id = 'td-pipeline.yml';
            const maxGapMinutes = 7;
            const maxRunningMinutes = 8;
            const maxQueuedMinutes = 3;

            const runsResp = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id,
              branch: 'main',
              per_page: 20,
            });

            const runs = runsResp.data.workflow_runs || [];
            const now = Date.now();
            const inProgress = runs.filter((r) => r.status === 'in_progress');
            const queued = runs.filter((r) => r.status === 'queued');

            const latestEffective =
              runs.find((r) => r.run_started_at || r.status === 'completed') || null;

            const latestAgeMin = latestEffective
              ? (now - new Date(latestEffective.run_started_at || latestEffective.created_at).getTime()) / 60000  
              : Number.POSITIVE_INFINITY;

            const hasHealthyRunning = inProgress.some((r) => {
              const age = (now - new Date(r.run_started_at || r.created_at).getTime()) / 60000;
              return age <= maxRunningMinutes;
            });

            const hasStaleQueued = queued.some((r) => {
              const age = (now - new Date(r.created_at).getTime()) / 60000;
              return age >= maxQueuedMinutes;
            });

            core.info(`TD latest run age: ${Number.isFinite(latestAgeMin) ? latestAgeMin.toFixed(1) : 'none'} min`);
            core.info(`TD in-progress runs: ${inProgress.length}`);
            core.info(`TD queued runs: ${queued.length}`);

            if (hasHealthyRunning) {
              core.info('TD pipeline already running in healthy window; no dispatch needed.');
              return;
            }

            if (latestAgeMin <= maxGapMinutes) {
              core.info(`TD pipeline freshness within ${maxGapMinutes} min; no dispatch needed.`);
              return;
            }

            if (queued.length > 0 && !hasStaleQueued) {
              core.info(`TD pipeline has fresh queued run(s) (<${maxQueuedMinutes} min); no dispatch yet.`);
              return;
            }


            await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id,
              ref: 'main',
              inputs: {
                force_public_sync: 'true',
              },
            });
            core.notice(`Triggered fallback dispatch for ${workflow_id}; latest age=${latestAgeMin.toFixed(1)} min`);
