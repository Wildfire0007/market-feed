name: TD Pipeline Scheduler Watchdog

"on":
  schedule:
    - cron: "2-59/5 * * * *"
  workflow_dispatch:

permissions:
  actions: write
  contents: read

jobs:
  watchdog:
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate pipeline gap and trigger fallback dispatch
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TD_BOT_PAT: ${{ secrets.TD_BOT_PAT }}
        run: |
          python - <<'PY'
          import json
          import os
          import sys
          import urllib.error
          import urllib.request
          from datetime import datetime, timezone

          repo = os.environ.get("GITHUB_REPOSITORY", "")
          if "/" not in repo:
            raise SystemExit(f"Invalid GITHUB_REPOSITORY: {repo}")

          owner, name = repo.split("/", 1)
          branch = "main"
          workflow_file = "td-pipeline.yml"
          base = f"https://api.github.com/repos/{owner}/{name}/actions/workflows/{workflow_file}"

          def github_request(method: str, url: str, token: str, payload: dict | None = None):
            data = None
            headers = {
              "Accept": "application/vnd.github+json",
              "Authorization": f"Bearer {token}",
              "X-GitHub-Api-Version": "2022-11-28",
            }
            if payload is not None:
              data = json.dumps(payload).encode("utf-8")
              headers["Content-Type"] = "application/json"
            req = urllib.request.Request(url, data=data, method=method, headers=headers)
            with urllib.request.urlopen(req, timeout=30) as resp:
              body = resp.read().decode("utf-8")
              return resp.status, body

          list_url = f"{base}/runs?branch={branch}&per_page=5"
          status, body = github_request("GET", list_url, os.environ["GH_TOKEN"])
          if status != 200:
            raise SystemExit(f"Failed listing runs ({status})")

          payload = json.loads(body)
          runs = payload.get("workflow_runs", [])

          now = datetime.now(timezone.utc)
          newest = runs[0] if runs else None
          queued_or_running = any(run.get("status") in {"queued", "in_progress"} for run in runs)

          age_seconds = None
          latest_completed = None
          for run in runs:
            if run.get("status") == "completed":
              latest_completed = run
              break

          if latest_completed and latest_completed.get("created_at"):
            created = datetime.fromisoformat(latest_completed["created_at"].replace("Z", "+00:00"))
            age_seconds = int((now - created).total_seconds())

          should_dispatch = (not queued_or_running) and (age_seconds is None or age_seconds > 480)

          dispatch_happened = False
          dispatch_error = ""

          if should_dispatch:
            dispatch_url = f"{base}/dispatches"
            dispatch_payload = {"ref": branch, "inputs": {"force_public_sync": "true"}}
            try:
              dispatch_status, _ = github_request("POST", dispatch_url, os.environ["GH_TOKEN"], dispatch_payload)
              if dispatch_status == 204:
                dispatch_happened = True
              else:
                dispatch_error = f"HTTP {dispatch_status}"
            except urllib.error.HTTPError as exc:
              body_text = exc.read().decode("utf-8", errors="replace") if hasattr(exc, "read") else ""
              dispatch_error = f"HTTP {exc.code}: {body_text}"

              if exc.code == 403 and "Resource not accessible by integration" in body_text and os.environ.get("TD_BOT_PAT"):
                try:
                  dispatch_status, _ = github_request("POST", dispatch_url, os.environ["TD_BOT_PAT"], dispatch_payload)
                  if dispatch_status == 204:
                    dispatch_happened = True
                    dispatch_error = ""
                  else:
                    dispatch_error = f"PAT HTTP {dispatch_status}"
                except urllib.error.HTTPError as pat_exc:
                  pat_body = pat_exc.read().decode("utf-8", errors="replace") if hasattr(pat_exc, "read") else ""
                  dispatch_error = f"PAT HTTP {pat_exc.code}: {pat_body}"

          latest_id = newest.get("id") if newest else "none"
          latest_status = newest.get("status") if newest else "none"
          age_value = age_seconds if age_seconds is not None else "none"
          print(
            f"last_run_id={latest_id} status={latest_status} age_seconds={age_value} "
            f"dispatch={str(dispatch_happened).lower()} queued_or_running={str(queued_or_running).lower()}"
          )

          if dispatch_error:
            print(f"dispatch_error={dispatch_error}")
            if "Resource not accessible by integration" in dispatch_error:
              print("fallback_hint=Set TD_BOT_PAT secret with repo+workflow scopes for dispatch fallback")
          PY
